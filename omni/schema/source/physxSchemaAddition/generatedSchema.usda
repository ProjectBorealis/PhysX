#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class "PhysxJointAxisAPI" (
    doc = """PhysX joint parameters defined per axis. Can be applied to a PhysicsJoint prim or
        the derived classes PhysicsRevoluteJoint, PhysicsPrismaticJoint or PhysicsSphericalJoint.
        For overlapping parameters with PhysxJointAPI, the parameters of PhysxJointAxisAPI take precedence for that axis. """
)
{
    float physxJointAxis:__INSTANCE_NAME__:armature = 0 (
        displayGroup = "Advanced"
        displayName = "Armature"
        doc = """Conceptually, armature represents the inertia of an actuator driving the joint. It is an artificial mass/inertia
            that is added to the joint-space inertia and can help stabilize an articulation. Note that this parameter is used only
            when the joint belongs to an articulation (see PhysicsArticulationRootAPI).
            Range: [0, inf)
            Units: Linear joint - mass
                   Angular joint - mass * distance^2"""
    )
    float physxJointAxis:__INSTANCE_NAME__:dynamicFrictionEffort = 0 (
        displayGroup = "Advanced"
        displayName = "Dynamic Friction Effort"
        doc = """Coulomb friction force or torque applied to resist motion in moving joints. Only applies to joints that are part of an articulation (see PhysicsArticulationRootAPI).
            Should be less than or equal to staticFrictionEffort.
            Range: [0, inf)
            Units: Linear joint - force (mass * distance / second^2)
                   Angular joint - torque (mass * distance^2 / second^2)"""
    )
    float physxJointAxis:__INSTANCE_NAME__:maxJointVelocity = 1000000 (
        displayGroup = "Advanced"
        displayName = "Maximum Joint Velocity"
        doc = """Maximum joint velocity. Only applies to joints that are part of an articulation (see PhysicsArticulationRootAPI).            
            The solver will apply appropriate joint-space impulses in order to enforce the per-axis joint-velocity limit.
            Range: [0, inf)
            Units: Linear joint - distance / seconds
                   Angular joint - degrees / seconds"""
    )
    float physxJointAxis:__INSTANCE_NAME__:staticFrictionEffort = 0 (
        displayGroup = "Advanced"
        displayName = "Static Friction Effort"
        doc = """Maximum static friction force or torque applied to resist motion in stationary joints. Only applies to joints that are part of an articulation (see PhysicsArticulationRootAPI).
            Prevents motion initiation until the applied force exceeds this threshold.
            Range: [0, inf)
            Units: Linear joint - force (mass * distance / second^2)
                   Angular joint - torque (mass * distance^2 / second^2)"""
    )
    float physxJointAxis:__INSTANCE_NAME__:viscousFrictionCoefficient = 0 (
        displayGroup = "Advanced"
        displayName = "Viscous Friction Coefficient"
        doc = """Coefficient used to calculate velocity-dependent friction effort. Only applies to joints that are part of an articulation (see PhysicsArticulationRootAPI).
            Total friction effort in moving joints = - sign(jointVelocity) * (dynamicFrictionEffort + viscousFrictionCoefficient * abs(jointVelocity))
            Range: [0, inf)
            Units: Linear joint - force * second / distance
                   Angular joint - torque * second / degrees"""
    )
}

class "PhysxDrivePerformanceEnvelopeAPI" (
    doc = """PhysX drive performance envelope parameters. Can be applied to a PhysicsJoint prim or
    the derived classes PhysicsRevoluteJoint, PhysicsPrismaticJoint (similar to PhysicsDriveAPI).
    For the PhysxDrivePerformanceEnvelopeAPI to take effect, the PhysicsDriveAPI must also be defined for the same axis. This is because the maxForce parameter of the PhysicsDriveAPI is utilized by the PhysxDrivePerformanceEnvelopeAPI.
    This API defines characteristics that limit the total joint force (drive force + external cached joint force)."""
)
{
    float physxDrivePerformanceEnvelope:__INSTANCE_NAME__:maxActuatorVelocity = inf (
        displayGroup = "Advanced"
        displayName = "Max Actuator Velocity"
        doc = """Defines speed limit above which actuator cannot produce any torque/force.
            Range: [0, inf)
            Units: Linear joint - distance / second
                   Angular joint - degrees / second"""
    )
    float physxDrivePerformanceEnvelope:__INSTANCE_NAME__:speedEffortGradient = 0 (
        displayGroup = "Advanced"
        displayName = "Speed-Effort Gradient"
        doc = """Defines how the maximum joint speed decreases as torque increases: 
            |jointVelocity| <= maxActuatorVelocity - speedEffortGradient * |jointForce|
            It incorporates back EMF effects of the motor.
            Range: [0, inf)
            Units: Linear joint - distance / second / force
                   Angular joint - degrees / second / torque"""
    )
    float physxDrivePerformanceEnvelope:__INSTANCE_NAME__:velocityDependentResistance = 0 (
        displayGroup = "Advanced"
        displayName = "Velocity Dependent Resistance"
        doc = """Defines a slope of the maxForce line of the performance envelope:
            |F| <= maxForce - velocityDependentResistance * |jointVelocity|
            The available max force/torque decreases as velocity magnitude increases due to the effect of the power losses of the motor.
            MaxForce parameter is defined in PhysicsDriveAPI.
            Range: [0, inf)
            Units: Linear joint - force * second / distance
                   Angular joint - torque * second / degrees"""
    )
}

class "PhysxSplinesSurfaceVelocityAPI" (
    doc = """PhysxSplinesSurfaceVelocityAPI enables surface velocity simulation
    that injects velocity to the solver through internal contact modify 
    callback. Surface velocity can be used typically for conveyer belt 
    simulation. It must be applied to a prim with UsdPhysicsRigidBodyAPI.
    The motion is defined by a velocity magnitude and UsdGeomBasisCurves that
    defines the motion direction.
    """
)
{
    rel physxSplinesSurfaceVelocity:surfaceVelocityCurve (
        displayName = "Surface Velocity Curve"
        doc = """Relationship to UsdGeomBasisCurves that defines the motion direction.
        When a contact is found the closest point on the spline is found and the
        motion direction is derived as the tangent at that spline point.
        
        Note that only one spline is supported.
        Note that runtime changes to the curve are not supported."""
    )
    bool physxSplinesSurfaceVelocity:surfaceVelocityEnabled = 1 (
        displayName = "Surface Velocity Enabled"
        doc = "Whether surface velocity is enabled or not."
    )
    float physxSplinesSurfaceVelocity:surfaceVelocityMagnitude = 0 (
        displayName = "Surface Velocity Magnitude"
        doc = """Surface velocity magnitude applied through contact modify callback. 
        Note that if objects are scaled, the surface velocity magnitude has to be
        adjusted.
        Units: distance/second."""
    )
}

class "PhysxBaseDeformableBodyAPI" (
    doc = """PhysxBaseDeformableBodyAPI provides PhysX specific parameters for simulating volume and surface deformables. 
          It can be applied to a prim with OmniPhysicsDeformableBodyAPI."""
)
{
    bool physxDeformableBody:disableGravity = 0 (
        displayName = "Disable Gravity"
        doc = "Disable gravity for the deformable body."
    )
    bool physxDeformableBody:enableSpeculativeCCD = 0 (
        displayName = "Enable Speculative CCD"
        doc = "Register a deformable body to dynamically adjust contact offset based on velocity."
    )
    float physxDeformableBody:linearDamping = 0 (
        displayName = "Linear Damping"
        doc = """Linear damping coefficient.
              Range: [0, inf)
              Units: 1 / seconds"""
    )
    float physxDeformableBody:maxDepenetrationVelocity = inf (
        displayGroup = "Advanced"
        displayName = "Max Depenetration Velocity"
        doc = """The maximum velocity permitted to be introduced by the solver to depenetrate intersections.
              Range: [0, inf)
              Units: distance / seconds"""
    )
    float physxDeformableBody:maxLinearVelocity = inf (
        displayName = "Max Linear Velocity"
        doc = """Maximum allowable linear velocity for the deformable body. 
              For surface deformables: If set to a negative value, the simulation determines a default value.
              Range: [0, inf)
              Units: distance / seconds"""
    )
    bool physxDeformableBody:selfCollision = 0 (
        displayName = "Enable Self Collision"
        doc = "Enables self collisions on the deformable, preventing self intersections."
    )
    float physxDeformableBody:selfCollisionFilterDistance = -inf (
        displayGroup = "Advanced"
        displayName = "Self Collision Filter Distance"
        doc = """Distance under which self-collisions are disabled. Default value -inf means default is picked by the simulation.
              Range: [2*physxCollision:restOffset, max_float]
              Units: distance"""
    )
    float physxDeformableBody:settlingDamping = 10 (
        displayGroup = "Advanced"
        displayName = "Settling Damping"
        doc = """Additional damping term if vertex velocity drops below settlingThreshold.
              Range: [0, inf)
              Units: 1 / seconds"""
    )
    float physxDeformableBody:settlingThreshold = 0.1 (
        displayGroup = "Advanced"
        displayName = "Settling Threshold"
        doc = """Threshold vertex velocity under which sleep damping is applied in addition to velocity damping.
              Range: [0, inf]
              Units: distance / seconds"""
    )
    float physxDeformableBody:sleepThreshold = 0.05 (
        displayName = "Sleep Threshold"
        doc = """Velocity threshold under which the vertex becomes a candidate for sleeping.
              Range: [0, inf)
              Units: distance / seconds"""
    )
    uint physxDeformableBody:solverPositionIterationCount = 16 (
        displayGroup = "Advanced"
        displayName = "Solver Position Iteration Count"
        doc = """ Number of solver position iterations per time step.
              Range: [1, 255]"""
    )
}

class "PhysxSurfaceDeformableBodyAPI" (
    apiSchemas = ["PhysxBaseDeformableBodyAPI"]
    doc = """PhysxSurfaceDeformableBodyAPI provides PhysX specific parameters for simulating surface deformables. It can 
          be applied to a prim with OmniPhysicsDeformableBodyAPI."""
)
{
    uint physxDeformableBody:collisionIterationMultiplier = 1 (
        displayGroup = "Advanced"
        displayName = "Collision Iteration Multiplier"
        doc = """Determines how many collision subiterations are used in each solver iteration.
              By default, collision constraints are applied once per solver iteration.
              Increasing this value applies collision constraints more frequently within each solver iteration.
              For example, a value of 2 means collision constraints are applied twice per solver iteration 
              (i.e., collision constraints are applied 2 x solverPositionIterationCount times per time step).
              Increasing this value does not update collision pairs more frequently; refer to collisionPairUpdateFrequency for that.
              Range [1, solverPositionIterationCount/2]"""
    )
    uint physxDeformableBody:collisionPairUpdateFrequency = 1 (
        displayGroup = "Advanced"
        displayName = "Collision Pair Update Frequency"
        doc = """Determines how often cloth-to-cloth collision pairs are updated during each time step. 
              Increasing this value results in more frequent updates to the contact pairs, which provides better contact points. 
              For example, a value of 2 means collision pairs are updated twice per time step: 
              once at the beginning and once in the middle of the time step (i.e., during the middle solver iteration). 
              If set to 0, the solver adaptively determines when to update the cloth-to-cloth contact pairs, instead of using a fixed frequency.
              Range [1, solverPositionIterationCount]"""
    )
}

class "PhysxDeformableMaterialAPI" (
    doc = """PhysxDeformableMaterialAPI provides PhysX specific material properties for volume and surface deformable
          materials with OmniPhysicsDeformableMaterialAPI."""
)
{
    float physxDeformableMaterial:elasticityDamping = 0 (
        displayGroup = "Advanced"
        displayName = "Elasticity Damping"
        doc = "Elasticity Damping"
    )
}

class "PhysxSurfaceDeformableMaterialAPI" (
    apiSchemas = ["PhysxDeformableMaterialAPI"]
    doc = """PhysxSurfaceDeformableMaterialAPI provides PhysX specific material properties for surface deformable
          materials with OmniPhysicsSurfaceDeformableMaterialAPI."""
)
{
    float physxDeformableMaterial:bendDamping = 0 (
        displayGroup = "Advanced"
        displayName = "Bend Damping"
        doc = "Bend Damping"
    )
}

class "PhysxAutoDeformableBodyAPI" (
    doc = """PhysxAutoDeformableBodyAPI is used to mark up a prim with OmniPhysicsDeformableBodyAPI for automatic, 
          parameter driven generation of simulation and collision mesh geometry. See PhysxAutoDeformableHexahedralMeshAPI
          and PhysxAutoDeformableMeshSimplificationAPI for more details. Only the geometry attributes are generated by
          OmniPhysX - the simulation and collision mesh primitives with corresponding APIs need to be created by the
          application."""
)
{
    bool physxDeformableBody:autoDeformableBodyEnabled = 1 (
        displayName = "Auto Deformable Body Enabled"
        doc = "Determins whether automatic mesh generation is enabled"
    )
    rel physxDeformableBody:cookingSourceMesh (
        displayName = "Cooking Source Mesh"
        doc = """Relationship to a single UsdGeomMesh prim that is used to generate the simulation and collision mesh
              geometry. The source mesh can reside outside of the deformable body hierachy."""
    )
}

class "PhysxAutoDeformableHexahedralMeshAPI" (
    doc = """PhysxAutoDeformableHexahedralMeshAPI specifies parameters related to volume deformable hexahedral simulation
          mesh generation. It is applied to a prim with OmniPhysicsDeformableBodyAPI and PhysxAutoDeformableBodyAPI."""
)
{
    uint physxDeformableBody:resolution = 0 (
        displayName = "Resolution"
        doc = """The number of hexahedral elements along the longest edge of the simulation mesh. A value of 0 indicates
              that the resolution is automatically determined"""
    )
}

class "PhysxAutoDeformableMeshSimplificationAPI" (
    doc = """PhysxAutoDeformableMeshSimplificationAPI specifies parameters related to mesh geometry simplification. The
          simplification process is applied to the cooking source mesh specified by the PhysxAutoDeformableBodyAPI."""
)
{
    bool physxDeformableBody:autoDeformableMeshSimplificationEnabled = 1 (
        displayName = "Mesh Simplification Enabled"
        doc = "Determins whether mesh simplification is enabled"
    )
    bool physxDeformableBody:forceConforming = 0 (
        displayName = "Force Conforming"
        doc = """Determins whether to force conformation with triangle surface. This parameter only affects the mesh
              geometry generation for volume deformable bodies."""
    )
    bool physxDeformableBody:remeshingEnabled = 1 (
        displayName = "Remeshing Enabled"
        doc = "Determins whether remeshing is enabled"
    )
    uint physxDeformableBody:remeshingResolution = 0 (
        displayName = "Remeshing Resolution"
        doc = "Remeshing Resolution, 0 indicates that the resolution is automatically determined"
    )
    uint physxDeformableBody:targetTriangleCount = 0 (
        displayName = "Target Triangle Count"
        doc = "Target Triangle Count, 0 indicates that the target count is automatically determined"
    )
}

class "PhysxAutoDeformableAttachmentAPI" (
    doc = """PhysxAutoDeformableAttachmentAPI is used to control automatic attachment and element collision filter
          generation and is applied to UsdGeomImageable prim. The necessary low level attachment and filter primitives,
          e.g. OmniPhysicsVtxVtxAttachment and OmniPhysicsElementCollisionFilter are provided by the application and are 
          assumed to be direct children of the prim this API is applied to.
          Either one of the attachable primitives needs to have a UsdPhysicsDeformableBodyAPI. One attachable primitive can 
          be an UsdGeomXformable."""
)
{
    rel physxAutoDeformableAttachment:attachable0 (
        displayName = "Attachable 0"
        doc = "Relationship to a prim which is either a UsdGeomXformable or has a UsdPhysicsDeformableBodyAPI."
    )
    rel physxAutoDeformableAttachment:attachable1 (
        displayName = "Attachable 1"
        doc = "Relationship to a prim which is either a UsdGeomXformable or has a UsdPhysicsDeformableBodyAPI."
    )
    float physxAutoDeformableAttachment:collisionFilteringOffset = -inf (
        displayName = "Collision Filtering Offset"
        doc = """Filtering ids are generated for deformable mesh vertices if their distance to the other actor's volume
            is smaller than the offset. Use heuristic by default.
            Range: [0, inf)
            Units: distance"""
    )
    float physxAutoDeformableAttachment:deformableVertexOverlapOffset = 0 (
        displayName = "Deformable Vertex Overlap Offset"
        doc = """Deformable mesh vertices are attached if their distance to the other actor's volume is smaller than the offset.
              Range: [0, inf)
              Units: distance"""
    )
    bool physxAutoDeformableAttachment:enableCollisionFiltering = 1 (
        displayName = "Enable Collision Filtering"
        doc = "Enables adding collision filtering in the vicinity of the attachment points."
    )
    bool physxAutoDeformableAttachment:enableDeformableFilteringPairs = 0 (
        displayGroup = "Advanced"
        displayName = "Enable Deformable Collision Filtering Pairs"
        doc = """Enables geometry pair based collision filtering for deformable-deformable attachments.
            By default a filtered geometry of one actor is filtered against all geometries of the other actor."""
    )
    bool physxAutoDeformableAttachment:enableDeformableVertexAttachments = 1 (
        displayName = "Enable Deformable Vertex Attachments"
        doc = "Enables attaching deformable mesh vertices which overlap with the other actor's volume."
    )
    bool physxAutoDeformableAttachment:enableRigidSurfaceAttachments = 0 (
        displayName = "Enable Rigid Surface Attachments"
        doc = "Enables sampling attachment points on the rigid actor's surface."
    )
    rel physxAutoDeformableAttachment:maskShapes (
        displayName = "Mask Shapes"
        doc = """Relationship to UsdGeomSphere, UsdGeomCube or UsdGeomCapsule geometries. The union of
            the shapes defines a mask volume within which attachment points are generated."""
    )
    float physxAutoDeformableAttachment:rigidSurfaceSamplingDistance = -inf (
        displayName = "Rigid Surface Sampling Distance"
        doc = """Attachment points on the rigid surface are positioned such that their typical neighbor distance matches the sampling distance. Use heuristic by default.
              Range: [0, inf)
              Units: distance"""
    )
}

