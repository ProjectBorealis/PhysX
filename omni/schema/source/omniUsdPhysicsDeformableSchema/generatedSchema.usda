#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class "OmniPhysicsBodyAPI" (
    doc = """Applies shared physics simulation attributes to a prim and marks it
    to be driven by a simulation. The specific behavior of the prim depends on
    additional physics APIs applied, which also dictate the prim type to which
    this API should be applied."""
)
{
    bool omniphysics:kinematicEnabled = 0 (
        displayName = "Kinematic Enabled"
        doc = """Determines whether the body is kinematic or not. A kinematic
        body is a body that is moved through animated poses or through
        user defined poses. The simulation derives velocities for the
        kinematic body based on the external motion. When a continuous motion
        is not desired, this kinematic flag should be set to false."""
    )
    rel omniphysics:simulationOwner (
        displayName = "Simulation Owner"
        doc = """Single PhysicsScene that will simulate this body. By
        default this is the first PhysicsScene found in the stage using
        UsdStage::Traverse()."""
    )
    uniform bool omniphysics:startsAsleep = 0 (
        displayName = "Starts as Asleep"
        doc = "Determines if the body is asleep when the simulation starts."
    )
}

class "OmniPhysicsDeformableBodyAPI" (
    apiSchemas = ["OmniPhysicsBodyAPI"]
    doc = """Applies physics deformable body attributes to a UsdGeomImageable
    prim with PhysicsBodyAPI and marks that prim including its children to be
    driven by a volume, surface or curves deformable simulation. The simulation
    state of a deformable object is represented by a dedicated mesh.
    Often, additional geometries within the deformable subtree are required for
    collision (with PhysicsCollisionAPI) or for graphics purposes. In such
    hierarchical setups the simulation mesh cannot be at the root, but needs to
    be nested as an immediate child below the root, because USD prohibits
    nesting of GPrims.
    The simulation mesh is marked with a deformable type-specific API: 
    - Volume: UsdGeomTetMesh with VolumeDeformableSimAPI
    - Surface: UsdGeomMesh with SurfaceDeformableSimAPI
    - Curves: UsdGeomBasisCurves/BasisCurvesNetwork with CurvesDeformableSimAPI
    During a simulation, the points and velocities of the given UsdGeomPointBased
    simulation mesh are updated. All other UsdGeomPointBased geometries in the
    hierarchy below the DeformableBodyAPI prim should move and deform
    accordingly. The material properties of the deformable body are to be
    governed by the applied materials with DeformableMaterialAPI,
    SurfaceDeformableMaterialAPI or CurvesDeformableMaterialAPI.
    The proposed curves deformable schema is a work in progress!"""
)
{
    bool omniphysics:deformableBodyEnabled = 1 (
        displayName = "Deformable Body Enabled"
        doc = "Determines if this PhysicsDeformableBodyAPI is enabled."
    )
    float omniphysics:mass = 0 (
        displayName = "Mass"
        doc = """If non-zero, directly specifies the mass of the deformable
        object and overrides the mass properties derived from material density.
        Note if mass is 0.0 it is ignored. PhysicsMassAPI is ignored for 
        deformable bodies.
        Units: mass"""
    )
}

class "OmniPhysicsBaseMaterialAPI" (
    doc = """ Adds simulation material properties to a Material. All collisions
    that have a relationship to this material will have their collision response
    defined through this material."""
)
{
    float omniphysics:density = 0 (
        displayName = "Density"
        doc = """If non-zero, defines the density of the material. This can be
        used for body mass computation, see PhysicsMassAPI.
        Note that if the density is 0.0 it is ignored.
        Units: mass/distance/distance/distance"""
    )
    float omniphysics:dynamicFriction = 0 (
        displayName = "Dynamic Friction"
        doc = """Dynamic friction coefficient.
        Units: None"""
    )
    float omniphysics:staticFriction = 0 (
        displayName = "Static Friction"
        doc = """Static friction coefficient.
        Units: None"""
    )
}

class "OmniPhysicsDeformableMaterialAPI" (
    apiSchemas = ["OmniPhysicsBaseMaterialAPI"]
    doc = """Applied to Material in addition to PhysicsMaterialAPI.
    Defines additional material properties for deformable bodies."""
)
{
    float omniphysics:poissonsRatio = 0.25 (
        displayName = "Poisson's Ratio"
        doc = """Poissons's ratio which defines the material's volume
        preservation under stress.
        Range: [0, 0.5]
        Units: None"""
    )
    float omniphysics:youngsModulus = 0 (
        displayName = "Young's Modulus"
        doc = """Young's modulus, i.e. the tensile stiffness of the material.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )
}

class "OmniPhysicsSurfaceDeformableMaterialAPI" (
    apiSchemas = ["OmniPhysicsDeformableMaterialAPI"]
    doc = """Applied to Material in addition to PhysicsMaterialAPI and
    DeformableMaterialAPI. Defines additional material properties for
    surface deformable bodies."""
)
{
    float omniphysics:surfaceBendStiffness = 0 (
        displayName = "Surface Bend Stiffness"
        doc = """Optional override for bending stiffness; by default derived
        from youngsModulus and surfaceThickness.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )
    float omniphysics:surfaceShearStiffness = 0 (
        displayName = "Surface Shear Stiffness"
        doc = """Optional override for shearing stiffness; by default derived
        from youngsModulus and surfaceThickness.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )
    float omniphysics:surfaceStretchStiffness = 0 (
        displayName = "Surface Stretch Stiffness"
        doc = """Optional override for stretching stiffness; by default derived
        from youngsModulus and surfaceThickness.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )
    float omniphysics:surfaceThickness = 0 (
        displayName = "Surface Thickness"
        doc = """Surface thickness.
        Units: distance"""
    )
}

class "OmniPhysicsCurvesDeformableMaterialAPI" (
    apiSchemas = ["OmniPhysicsDeformableMaterialAPI"]
    doc = """The proposed curves deformable schema is a work in progress!
    Applied to Material in addition to PhysicsMaterialAPI and
    DeformableMaterialAPI. Defines additional material properties for
    curves deformable bodies."""
)
{
    float omniphysics:curveBendStiffness = 0 (
        displayName = "Curve Bend Stiffness"
        doc = """Optional override for bending stiffness; by default derived
        from youngsModulus and curveThickness.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )
    float omniphysics:curveStretchStiffness = 0 (
        displayName = "Curve Stretch Stiffness"
        doc = """Optional override for stretching stiffness; by default derived
        from youngsModulus and curveThickness.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )
    float omniphysics:curveThickness = 0 (
        displayName = "Curve Thickness"
        doc = """Diameter along curve.
        Units: distance"""
    )
    float omniphysics:curveTwistStiffness = 0 (
        displayName = "Curve Twist Stiffness"
        doc = """Optional override for twisting stiffness; by default derived
        from youngsModulus and curveThickness.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )
}

class "OmniPhysicsVolumeDeformableSimAPI" (
    doc = """Identifies a UsdGeomTetMesh to be used as the simulation mesh for
    a volume deformable body, distinguishing it from geometries used exclusively
    for graphics or collision.
    A volume deformable body requires exactly one tetrahedral simulation mesh,
    which can either have both DeformableBodyAPI and VolumeDeformableSimAPI
    applied, or, in a hierarchical setup, be the direct child of the root with
    DeformableBodyAPI.
    The simulation API also defines attributes to describe the rest shape of the 
    volume deformable body."""
)
{
    point3f[] omniphysics:restShapePoints (
        displayName = "Rest Shape Points"
        doc = """Describes the rest shape in (local) space for a deformable body
        simulation mesh."""
    )
    int4[] omniphysics:restTetVtxIndices (
        displayName = "Rest Tetrahedron Vertex Indices"
        doc = """Per tetrahedral element indices into restShapePoints to describe
        the rest shape of each tetrahedron. This allows for restTetIndices to
        have length up to 4*len(restShapePoints) to allow for disjoint
        per-element rest shape description, or a more compact array when all
        tetrahedra share coincident points to describe the rest shape of the
        deformable body simulation tetmesh."""
    )
}

class "OmniPhysicsSurfaceDeformableSimAPI" (
    doc = """Identifies a UsdGeomMesh to be used as the simulation mesh for
    a surface deformable body, distinguishing it from geometries used
    exclusively for graphics or collision.
    A surface deformable body requires exactly one simulation mesh, limited to
    only triangular faces. The simulation mesh can either have both
    DeformableBodyAPI and SurfaceDeformableSimAPI applied, or, in a hierarchical
    setup, be the direct child of the root with DeformableBodyAPI.
    The simulation API also defines attributes to describe the rest shape of the 
    surface deformable body."""
)
{
    int2[] omniphysics:restAdjTriPairs (
        displayName = "Adjacent Triangle Pairs"
        doc = """Array of adjacent triangle pairs to define dihedral rest bending
        angles explicitely, overriding the default rest angles. Each entry
        corresponds to an angle specified in restBendAngles."""
    )
    float[] omniphysics:restBendAngles (
        displayName = "Rest Bend Angles"
        doc = """Rest angles in degrees. Length of restBendAngles should match
        length of restAdjTriPairs. For all adjacent triangle pairs not specified
        via restAdjTriPairs and restBendAngles, the default dihedral angle given
        by restBendAnglesDefault is assumed. 
        Range: [-180.0, 180.0)
        Units: degrees"""
    )
    uniform token omniphysics:restBendAnglesDefault = "flatDefault" (
        allowedTokens = ["flatDefault", "restShapeDefault"]
        displayName = "Rest Bend Angles Default"
        doc = '''Default method for defining rest dihedral angles between
        adjacent triangles, which are not explicitely specified with
        restAdjTriPairs and restBendAngles:
        "flatDefault" - Default rest dihedral bending angles are zero.
        "restShapeDefault" - Default rest dihedral bending angles are defined by
        the normals of the adjacent triangles in the configuration given by the
        restShapePoints. The adjacency is defined by the topology of the 
        simulation mesh: GeomMesh:faceVertexIndices.'''
    )
    point3f[] omniphysics:restShapePoints (
        displayName = "Rest Shape Points"
        doc = """Describes the per triangle planar shape in (local) space for a
        surface deformable body. While panel based cloth systems may only
        require UV coordinates and not require a third component, doing so makes
        it convenient for an application to support non-planar shells with
        a rest shape described in 3D.
        One can still use this array for per-face UVs with a little wasted space."""
    )
    int3[] omniphysics:restTriVtxIndices (
        displayName = "Rest Triangle Vertex Indices"
        doc = """Per triangle element indices into restShapePoints to describe
        the rest shape of each triangle face. This allows for
        restTriVtxIndices to have length up to 3*len(restShapePoints) to
        allow for a disjoint per-element rest shape description, or a
        more compact array when all triangles share conincident points
        to describe the rest shape of the surface deformable body triangle mesh."""
    )
}

class "OmniPhysicsCurvesDeformableSimAPI" (
    doc = """The proposed curves deformable schema is a work in progress! 
    Identifies a UsdGeomBasisCurves or UsdGeomBasisCurvesNetwork to be 
    used as the simulation geometry for a curves deformable body, distinguishing
    it from geometries used exclusively for graphics or collision.
    A curves deformable body requires exactly one simulation curves geometry,
    limited to only linear segments. The simulation geometry can either have
    both DeformableBodyAPI and CurvesDeformableSimAPI applied, or, in
    a hierarchical setup, be the direct child of the root with DeformableBodyAPI.
    The simulation API also defines attributes to describe the rest shape of the 
    curves deformable body."""
)
{
    int[] omniphysics:restCrvVtxIndices (
        displayName = "Rest Curve Vertex Indices"
        doc = """If the shape is a UsdGeomBasisCurvesNetwork, restCrvVtxIndices
        specifies a flat list of the index into the restShapePoints attribute of
        each vertex of each curve. This allows restCrvVtxIndices to describe
        a disjoint per-curve rest shape that differs from any coincident points
        described by curveVertexIndices. If the simulation geometry is
        a UsdGeomBasisCurves, then restCrvVtxIndices is not applicable."""
    )
    normal3f[] omniphysics:restNormals (
        displayName = "Rest Normals"
        doc = """Describes the orientation of the rest curves.
        Like normals, restNormals is not a generic primvar but the number of
        elements in this attribute will be determined by its 'interpolation'.
        See For example, varying
        interpolation can be used to specify a normal per curve segment, as
        described by \\ref UsdGeomBasisCurves_PrimvarInterpolation."""
    )
    point3f[] omniphysics:restShapePoints (
        displayName = "Rest Shape Points"
        doc = """Describes the rest shape in (local) space for
        a UsdGeomBasisCurves or a UsdGeomBasisCurvesNetwork."""
    )
}

class "OmniPhysicsDeformablePoseAPI" (
    doc = """Defines a deformable mesh pose which can be used for one or
    multiple purposes. Multiple pose APIs can be specified for different
    purposes. The pose API instance name can be chosen arbitrarily."""
)
{
    point3f[] deformablePose:__INSTANCE_NAME__:omniphysics:points (
        displayName = "Points"
        doc = """The points defining the pose of a mesh. The number of
        points needs to match the number of points in the mesh."""
    )
    uniform token[] deformablePose:__INSTANCE_NAME__:omniphysics:purposes (
        allowedTokens = ["bindPose", "selfCollisionFilterPose"]
        displayName = "Purposes"
        doc = '''The set of purposes this pose is used for.
        "bindPose" - The pose in which graphical UsdGeomPointBased and
        deformable simulation meshes are bound to each other. The bindPose
        purpose needs to be specified on the simulation mesh and all graphical
        meshes if a specific bind pose is needed. If not specified, the default
        mesh points are used for the embedding.
        "selfCollisionFilterPose" - The pose used for self collision 
        filtering. Ovelapping domains of the mesh in this pose are excluded 
        from self collision. The selfCollisionFilterPose purpose needs to be
        specified on the simulation mesh only. If not specified, the default
        mesh points are used for self collision filtering.'''
    )
}

class OmniPhysicsAttachment "OmniPhysicsAttachment" (
    doc = """Base class for attachments between two suitable deformable body
    simulation meshes, or between a deformable body simulation mesh and 
    a UsdGeomXformable's coordinate frame.
    """
)
{
    bool omniphysics:attachmentEnabled = 1 (
        displayName = "Attachment Enabled"
        doc = "Determines if this PhysicsAttachment is enabled."
    )
    float omniphysics:damping = 0 (
        displayName = "Damping"
        doc = """Proportional factor of the force acting against the direction
        of relative motion.
        Range: [0, inf)
        Units: mass/second"""
    )
    rel omniphysics:src0 (
        displayName = "Source 0"
        doc = """Relationship to a single deformable body's simulation mesh.
        The attachment locations are specified in the derived attachment
        class."""
    )
    rel omniphysics:src1 (
        displayName = "Source 1"
        doc = """Relationship to a single deformable body's simulation mesh or
        a single UsdGeomXformable. The attachment locations are specified in the
        derived attachment class."""
    )
    float omniphysics:stiffness = inf (
        displayName = "Stiffness"
        doc = '''Distance proportional factor for the attachment.
        "inf" implies a hard constraint if the simulator can support it.
        Range: [0, inf)
        Units: mass/second/second'''
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class OmniPhysicsVtxVtxAttachment "OmniPhysicsVtxVtxAttachment" (
    doc = """Describes a fixed binding attachment between vertices of two
    UsdGeomPointBased deformable body simulation meshes."""
)
{
    bool omniphysics:attachmentEnabled = 1 (
        displayName = "Attachment Enabled"
        doc = "Determines if this PhysicsAttachment is enabled."
    )
    float omniphysics:damping = 0 (
        displayName = "Damping"
        doc = """Proportional factor of the force acting against the direction
        of relative motion.
        Range: [0, inf)
        Units: mass/second"""
    )
    rel omniphysics:src0 (
        displayName = "Source 0"
        doc = """Relationship to a single deformable body's simulation mesh.
        The attachment locations are specified in the derived attachment
        class."""
    )
    rel omniphysics:src1 (
        displayName = "Source 1"
        doc = """Relationship to a single deformable body's simulation mesh or
        a single UsdGeomXformable. The attachment locations are specified in the
        derived attachment class."""
    )
    float omniphysics:stiffness = inf (
        displayName = "Stiffness"
        doc = '''Distance proportional factor for the attachment.
        "inf" implies a hard constraint if the simulator can support it.
        Range: [0, inf)
        Units: mass/second/second'''
    )
    int[] omniphysics:vtxIndicesSrc0 (
        displayName = "Vertex Indices Source 0"
        doc = "Array of vertex indices from UsdGeomPointBased src0."
    )
    int[] omniphysics:vtxIndicesSrc1 (
        displayName = "Vertex Indices Source 1"
        doc = """Array of vertex indices from UsdGeomPointBased src1.
        There should be exactly one vertex index for each vertex index
        in vtxIndicesSrc0."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class OmniPhysicsVtxTriAttachment "OmniPhysicsVtxTriAttachment" (
    doc = """Describes a fixed binding attachment between vertices and triangle
    faces of two suitable deformable body simulation meshes. The src1 relationship
    should point to either a UsdGeomMesh or a UsdGeomTetMesh (in which case surface 
    triangles are referenced)."""
)
{
    bool omniphysics:attachmentEnabled = 1 (
        displayName = "Attachment Enabled"
        doc = "Determines if this PhysicsAttachment is enabled."
    )
    float omniphysics:damping = 0 (
        displayName = "Damping"
        doc = """Proportional factor of the force acting against the direction
        of relative motion.
        Range: [0, inf)
        Units: mass/second"""
    )
    rel omniphysics:src0 (
        displayName = "Source 0"
        doc = """Relationship to a single deformable body's simulation mesh.
        The attachment locations are specified in the derived attachment
        class."""
    )
    rel omniphysics:src1 (
        displayName = "Source 1"
        doc = """Relationship to a single deformable body's simulation mesh or
        a single UsdGeomXformable. The attachment locations are specified in the
        derived attachment class."""
    )
    float omniphysics:stiffness = inf (
        displayName = "Stiffness"
        doc = '''Distance proportional factor for the attachment.
        "inf" implies a hard constraint if the simulator can support it.
        Range: [0, inf)
        Units: mass/second/second'''
    )
    vector3f[] omniphysics:triCoordsSrc1 (
        displayName = "Triangle Coordinates Source 1"
        doc = """Triangle relative coordinates of the form U,V portion of
        barycentric UVW coordinates and a normal offset from the
        triangle. There should be exactly one set of triangle coordinates
        corresponding to each vertex index and triangle index."""
    )
    int[] omniphysics:triIndicesSrc1 (
        displayName = "Triangle Indices Source 1"
        doc = """Array of triangle indices from UsdGeomMesh/UsdGeomTetMesh src1.
        There should be exactly one triangle index for each vertex index in
        vtxIndicesSrc0."""
    )
    int[] omniphysics:vtxIndicesSrc0 (
        displayName = "Vertex Indices Source 0"
        doc = "Array of vertex indices from UsdGeomPointBased src0"
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class OmniPhysicsVtxTetAttachment "OmniPhysicsVtxTetAttachment" (
    doc = """Describes a fixed binding attachment between vertices and
    tetrahedra of two suitable deformable body simulation meshes.
    The src1 relationship should point to a UsdGeomTetMesh."""
)
{
    bool omniphysics:attachmentEnabled = 1 (
        displayName = "Attachment Enabled"
        doc = "Determines if this PhysicsAttachment is enabled."
    )
    float omniphysics:damping = 0 (
        displayName = "Damping"
        doc = """Proportional factor of the force acting against the direction
        of relative motion.
        Range: [0, inf)
        Units: mass/second"""
    )
    rel omniphysics:src0 (
        displayName = "Source 0"
        doc = """Relationship to a single deformable body's simulation mesh.
        The attachment locations are specified in the derived attachment
        class."""
    )
    rel omniphysics:src1 (
        displayName = "Source 1"
        doc = """Relationship to a single deformable body's simulation mesh or
        a single UsdGeomXformable. The attachment locations are specified in the
        derived attachment class."""
    )
    float omniphysics:stiffness = inf (
        displayName = "Stiffness"
        doc = '''Distance proportional factor for the attachment.
        "inf" implies a hard constraint if the simulator can support it.
        Range: [0, inf)
        Units: mass/second/second'''
    )
    vector3f[] omniphysics:tetCoordsSrc1 (
        displayName = "Tetrahedra Coordinates Source 1"
        doc = """Barycentric coordinates of the form U,V,W of the point wrt.
        the points of the tetrahedra. There should be exactly one
        set of tetrahedra coordinates corresponding to each vertex index and
        tet index."""
    )
    int[] omniphysics:tetIndicesSrc1 (
        displayName = "Tetrahedron Indices Source 1"
        doc = """Array of tetrahedron indices from UsdGeomTetMesh src1.
        There should be exactly one tet index for each vertex index in
        vtxIndicesSrc0."""
    )
    int[] omniphysics:vtxIndicesSrc0 (
        displayName = "Vertex Indices Source 0"
        doc = "Array of vertex indices from UsdGeomPointBased src0"
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class OmniPhysicsVtxCrvAttachment "OmniPhysicsVtxCrvAttachment" (
    doc = """The proposed curves deformable schema is a work in progress!
    Describes a fixed binding attachment between vertices and curves
    of two suitable deformable body simulation meshes. The src1 relationship
    should point to a UsdGeomBasisCurves or UsdGeomBasisCurvesNetwork."""
)
{
    bool omniphysics:attachmentEnabled = 1 (
        displayName = "Attachment Enabled"
        doc = "Determines if this PhysicsAttachment is enabled."
    )
    vector3f[] omniphysics:crvSegCoordsSrc1 (
        displayName = "Curve Segment Coordinates Source 1"
        doc = """Segment relative coordinates of the form U (parametric
        coordinate along the segment), VW (offset vector defined in the
        coordinate frame spanned by {N, NxT}, where N is the interpolated unit
        curve normal and T is the unit vector tangential to the segment). 
        There should be exactly one coordinate set for each curve segment in
        crvSegIndicesSrc1."""
    )
    int2[] omniphysics:crvSegIndicesSrc1 (
        displayName = "Curve Segment Indices Source 1"
        doc = """Array of (curve index, segment index) pairs from src0.
        There should be exactly one pair for each vertex index in vtxIndicesSrc0.
        The curve index specifies the index of the curve from
        UsdGeomBasisCurves/UsdGeomBasisCurvesNetwork src1, and the
        segment index identifies the segment within the curve."""
    )
    float omniphysics:damping = 0 (
        displayName = "Damping"
        doc = """Proportional factor of the force acting against the direction
        of relative motion.
        Range: [0, inf)
        Units: mass/second"""
    )
    rel omniphysics:src0 (
        displayName = "Source 0"
        doc = """Relationship to a single deformable body's simulation mesh.
        The attachment locations are specified in the derived attachment
        class."""
    )
    rel omniphysics:src1 (
        displayName = "Source 1"
        doc = """Relationship to a single deformable body's simulation mesh or
        a single UsdGeomXformable. The attachment locations are specified in the
        derived attachment class."""
    )
    float omniphysics:stiffness = inf (
        displayName = "Stiffness"
        doc = '''Distance proportional factor for the attachment.
        "inf" implies a hard constraint if the simulator can support it.
        Range: [0, inf)
        Units: mass/second/second'''
    )
    int[] omniphysics:vtxIndicesSrc0 (
        displayName = "Vertex Indices"
        doc = "Array of vertex indices from UsdGeomPointBased src0."
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class OmniPhysicsVtxXformAttachment "OmniPhysicsVtxXformAttachment" (
    doc = """Describes a fixed binding attachment between vertices and a
    UsdGeomXformable's coordinate frame. The vertices must always be from a
    deformable body's simulation mesh. If the xformable is a rigid body or
    a prim of the subtree of a rigid body, then the attachment is treated by
    the solver as a two way constraint."""
)
{
    bool omniphysics:attachmentEnabled = 1 (
        displayName = "Attachment Enabled"
        doc = "Determines if this PhysicsAttachment is enabled."
    )
    float omniphysics:damping = 0 (
        displayName = "Damping"
        doc = """Proportional factor of the force acting against the direction
        of relative motion.
        Range: [0, inf)
        Units: mass/second"""
    )
    point3f[] omniphysics:localPositionsSrc1 (
        displayName = "Local Positions Source 1"
        doc = """Spatial offsets of the attachment locations in the coordinate
        frame described by UsdGeomXformable src1."""
    )
    rel omniphysics:src0 (
        displayName = "Source 0"
        doc = """Relationship to a single deformable body's simulation mesh.
        The attachment locations are specified in the derived attachment
        class."""
    )
    rel omniphysics:src1 (
        displayName = "Source 1"
        doc = """Relationship to a single deformable body's simulation mesh or
        a single UsdGeomXformable. The attachment locations are specified in the
        derived attachment class."""
    )
    float omniphysics:stiffness = inf (
        displayName = "Stiffness"
        doc = '''Distance proportional factor for the attachment.
        "inf" implies a hard constraint if the simulator can support it.
        Range: [0, inf)
        Units: mass/second/second'''
    )
    int[] omniphysics:vtxIndicesSrc0 (
        displayName = "Vertex Indices Source 0"
        doc = "Array of vertex indices from UsdGeomPointBased src0."
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class OmniPhysicsTetXformAttachment "OmniPhysicsTetXformAttachment" (
    doc = """Describes a fixed binding attachment between tetrahedra and a
    UsdGeomXformable's coordinate frame. The tetrahedra must always be from a
    deformable body's simulation mesh. If the xformable is a rigid body or
    a prim of the subtree of a rigid body, then the attachment is treated by
    the solver as a two way constraint."""
)
{
    bool omniphysics:attachmentEnabled = 1 (
        displayName = "Attachment Enabled"
        doc = "Determines if this PhysicsAttachment is enabled."
    )
    float omniphysics:damping = 0 (
        displayName = "Damping"
        doc = """Proportional factor of the force acting against the direction
        of relative motion.
        Range: [0, inf)
        Units: mass/second"""
    )
    point3f[] omniphysics:localPositionsSrc1 (
        displayName = "Local Positions Source 1"
        doc = """Spatial offsets of the attachment locations in the coordinate
        frame described by UsdGeomXformable src1."""
    )
    rel omniphysics:src0 (
        displayName = "Source 0"
        doc = """Relationship to a single deformable body's simulation mesh.
        The attachment locations are specified in the derived attachment
        class."""
    )
    rel omniphysics:src1 (
        displayName = "Source 1"
        doc = """Relationship to a single deformable body's simulation mesh or
        a single UsdGeomXformable. The attachment locations are specified in the
        derived attachment class."""
    )
    float omniphysics:stiffness = inf (
        displayName = "Stiffness"
        doc = '''Distance proportional factor for the attachment.
        "inf" implies a hard constraint if the simulator can support it.
        Range: [0, inf)
        Units: mass/second/second'''
    )
    vector3f[] omniphysics:tetCoordsSrc0 (
        displayName = "Tetrahedra Coordinates Source 0"
        doc = """Barycentric coordinates of the form U,V,W of the point wrt.
        the points of the tetrahedra. There should be exactly one
        set of tetrahedra coordinates corresponding to each tet index."""
    )
    int[] omniphysics:tetIndicesSrc0 (
        displayName = "Tetrahedron Indices Source 0"
        doc = "Array of tetrahedron indices from UsdGeomTetMesh src0."
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class OmniPhysicsTriTriAttachment "OmniPhysicsTriTriAttachment" (
    doc = """Describes a fixed binding attachment between a point on a triangle
    face and a point on another triangle face of two suitable deformable body
    simulation meshes. Both src0 and src1 relationship should each point to
    either a UsdGeomMesh or a UsdGeomTetMesh (in which case surface 
    triangles are referenced)."""
)
{
    bool omniphysics:attachmentEnabled = 1 (
        displayName = "Attachment Enabled"
        doc = "Determines if this PhysicsAttachment is enabled."
    )
    float omniphysics:damping = 0 (
        displayName = "Damping"
        doc = """Proportional factor of the force acting against the direction
        of relative motion.
        Range: [0, inf)
        Units: mass/second"""
    )
    rel omniphysics:src0 (
        displayName = "Source 0"
        doc = """Relationship to a single deformable body's simulation mesh.
        The attachment locations are specified in the derived attachment
        class."""
    )
    rel omniphysics:src1 (
        displayName = "Source 1"
        doc = """Relationship to a single deformable body's simulation mesh or
        a single UsdGeomXformable. The attachment locations are specified in the
        derived attachment class."""
    )
    float omniphysics:stiffness = inf (
        displayName = "Stiffness"
        doc = '''Distance proportional factor for the attachment.
        "inf" implies a hard constraint if the simulator can support it.
        Range: [0, inf)
        Units: mass/second/second'''
    )
    vector3f[] omniphysics:triCoordsSrc0 (
        displayName = "Triangle Coordinates Source 0"
        doc = """Triangle relative coordinates of the form U,V portion of
        barycentric UVW coordinates and a normal offset from the triangle.
        There should be exactly one set of triangle coordinates
        corresponding to each entry in triIndicesSrc0."""
    )
    vector3f[] omniphysics:triCoordsSrc1 (
        displayName = "Triangle Coordinates Source 1"
        doc = """Triangle relative coordinates of the form U,V portion of
        barycentric UVW coordinates and a normal offset from the triangle. 
        There should be exactly one set of triangle coordinates
        corresponding to each entry in triIndicesSrc1."""
    )
    int[] omniphysics:triIndicesSrc0 (
        displayName = "Triangle Indices Source 0"
        doc = "Array of triangle indices from UsdGeomMesh/UsdGeomTetMesh src0."
    )
    int[] omniphysics:triIndicesSrc1 (
        displayName = "Triangle Indices Source 1"
        doc = """Array of triangle indices from UsdGeomMesh/UsdGeomTetMesh src1.
        There should be exactly one triangle index for each triangle index in
        triIndicesSrc0."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class OmniPhysicsElementCollisionFilter "OmniPhysicsElementCollisionFilter" (
    doc = """Describes an element wise collision filter for deformable body
    collision prims with PhysicsCollisionAPI. The filter specifies two suitable
    collision GPrims which are the source of the elements. The sources may be
    indentical to control self collision filtering. At least one source prim
    needs to represent a deformable body collider, and up to one can either
    be a rigid body or static collider.
    The filtering for deformable sources is based on element indices representing
    - triangles for UsdGeomMesh
    - surface triangles for UsdGeomTetMesh
    - segments for UsdGeomBasisCurves/UsdGeomBasisCurvesNetwork
    - points for UsdGeomPoints
    Filtering a specific triangle of a mesh means omitting collision tests
    against its face, vertex, and edge features. However, vertices and edges
    shared with adjacent unfiltered triangles are not filtered. Similarly,
    vertices of filtered curve segments are not filtered if they are shared with
    adjacent unfiltered segments.
    If the source is either a static or rigid collider, the whole geometry is
    filtered and no elements need to be specified. Which elements are filtered
    against which, is specified using pairs of element groups. Each pair of
    groups defines the elements of both sources that should not collide with
    each other.
    E.g.: triangles [4, 5, 6] of one collider mesh are each not colliding
    against any triangles [12, 13] of the other collider mesh.
    The group sizes are specified with groupElemCounts0 and groupElemCounts1,
    two arrays of matching size. The element indices of each group are
    consecutively stored for all groups in groupElemIndices0 and
    groupElemIndices1, similarly to how faceVertexCounts specifies the number of
    vertices per face and faceVertexIndices specifies the vertex indices per
    face in order.
    Two special cases: 
    - An empty groupElemCounts array indicates that the
    corresponding source is filtered as a whole, for example for rigid or static
    colliders.
    - A group element count of zero indicates that the corresponding source is
    filtered as a whole with respect to the paired up group of the other source."""
)
{
    bool omniphysics:filterEnabled = 1 (
        displayName = "Filter Enabled"
        doc = "Determines if this PhysicsElementCollisionFilter is enabled."
    )
    uint[] omniphysics:groupElemCounts0 (
        displayName = "Group Element Counts 0"
        doc = """Array of element counts per filter group for src0. Same size as 
        groupElemCounts1 or empty."""
    )
    uint[] omniphysics:groupElemCounts1 (
        displayName = "Group Element Counts 1"
        doc = """Array of element counts per filter group for src1. Same size as 
        groupElemCounts0 or empty."""
    )
    uint[] omniphysics:groupElemIndices0 (
        displayName = "Group Element Indices 0"
        doc = """Array of element indices ordered according to groupElemCounts0,
        referencing elements of src0. If the src is a curves prim,
        then each entry consists of two indices: (curve index, segment index)."""
    )
    uint[] omniphysics:groupElemIndices1 (
        displayName = "Group Element Indices 1"
        doc = """Array of element indices ordered according to groupElemCounts1,
        referencing elements of src1. If the src is a curves prim, 
        then each entry consists of two indices: (curve index, segment index)."""
    )
    rel omniphysics:src0 (
        displayName = "Source 0"
        doc = """Relationship to a single deformable body's collider which is
        the source of elements referenced by groupElemIndices0 or
        a rigid body/static collider."""
    )
    rel omniphysics:src1 (
        displayName = "Source 1"
        doc = """Relationship to a single deformable body's collider which is
        the source of elements referenced by groupElemIndices1 
        or a rigid body/static collider."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

