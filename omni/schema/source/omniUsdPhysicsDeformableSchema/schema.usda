#usda 1.0
(
    "OmniUsdPhysicsDeformable Codeless Schema"
    subLayers = [
        @usdGeom/schema.usda@,
    ]
)

over "GLOBAL" (
    customData = {
        string libraryName      = "omniUsdPhysicsDeformableSchema"
        string libraryPath      = "pxr/usd/omniUsdPhysicsDeformableSchema"
        bool skipCodeGeneration = true
    }
)
{
}

class "OmniPhysicsBodyAPI"
(
    customData = {
        string className = "BodyAPI"
    }
    doc = """Applies shared physics simulation attributes to a prim and marks it
    to be driven by a simulation. The specific behavior of the prim depends on
    additional physics APIs applied, which also dictate the prim type to which
    this API should be applied."""

    inherits = </APISchemaBase>
)
{
    bool omniphysics:kinematicEnabled = false (
        customData = {
            string apiName = "kinematicEnabled"
        }
        displayName = "Kinematic Enabled"
        doc = """Determines whether the body is kinematic or not. A kinematic
        body is a body that is moved through animated poses or through
        user defined poses. The simulation derives velocities for the
        kinematic body based on the external motion. When a continuous motion
        is not desired, this kinematic flag should be set to false."""
    )

    rel omniphysics:simulationOwner (
        customData = {
            string apiName = "simulationOwner"
        }
        displayName = "Simulation Owner"
        doc = """Single PhysicsScene that will simulate this body. By
        default this is the first PhysicsScene found in the stage using
        UsdStage::Traverse()."""
    )

    uniform bool omniphysics:startsAsleep = false (
        customData = {
            string apiName = "startsAsleep"
        }
        displayName = "Starts as Asleep"
        doc = "Determines if the body is asleep when the simulation starts."
    )
}

class "OmniPhysicsDeformableBodyAPI"
(
    customData = {
        string className = "DeformableBodyAPI"
    }

    doc = """Applies physics deformable body attributes to a UsdGeomImageable
    prim with PhysicsBodyAPI and marks that prim including its children to be
    driven by a volume, surface or curves deformable simulation. The simulation
    state of a deformable object is represented by a dedicated mesh.
    Often, additional geometries within the deformable subtree are required for
    collision (with PhysicsCollisionAPI) or for graphics purposes. In such
    hierarchical setups the simulation mesh cannot be at the root, but needs to
    be nested as an immediate child below the root, because USD prohibits
    nesting of GPrims.
    The simulation mesh is marked with a deformable type-specific API: 
    - Volume: UsdGeomTetMesh with VolumeDeformableSimAPI
    - Surface: UsdGeomMesh with SurfaceDeformableSimAPI
    - Curves: UsdGeomBasisCurves/BasisCurvesNetwork with CurvesDeformableSimAPI
    During a simulation, the points and velocities of the given UsdGeomPointBased
    simulation mesh are updated. All other UsdGeomPointBased geometries in the
    hierarchy below the DeformableBodyAPI prim should move and deform
    accordingly. The material properties of the deformable body are to be
    governed by the applied materials with DeformableMaterialAPI,
    SurfaceDeformableMaterialAPI or CurvesDeformableMaterialAPI.
    The proposed curves deformable schema is a work in progress!"""

    inherits = </APISchemaBase>
    prepend apiSchemas = ["OmniPhysicsBodyAPI"]
)
{
    bool omniphysics:deformableBodyEnabled = true (
        customData = {
            string apiName = "deformableBodyEnabled"
        }
        displayName = "Deformable Body Enabled"
        doc = """Determines if this PhysicsDeformableBodyAPI is enabled."""
    )

    float omniphysics:mass = 0.0 (
        customData = {
            string apiName = "mass"
        }
        displayName = "Mass"
        doc = """If non-zero, directly specifies the mass of the deformable
        object and overrides the mass properties derived from material density.
        Note if mass is 0.0 it is ignored. PhysicsMassAPI is ignored for 
        deformable bodies.
        Units: mass"""
    )
}

class "OmniPhysicsBaseMaterialAPI"
(
    customData = {
        string className = "BaseMaterialAPI"
    }
    doc = """ Adds simulation material properties to a Material. All collisions
    that have a relationship to this material will have their collision response
    defined through this material."""

    inherits = </APISchemaBase>
)
{
    float omniphysics:dynamicFriction = 0.0 (
        customData = {
            string apiName = "dynamicFriction"
        }
        displayName = "Dynamic Friction"
        doc = """Dynamic friction coefficient.
        Units: None"""
    )

    float omniphysics:staticFriction = 0.0 (
        customData = {
            string apiName = "staticFriction"
        }
        displayName = "Static Friction"
        doc = """Static friction coefficient.
        Units: None"""
    )

    float omniphysics:density = 0.0 (
        customData = {
            string apiName = "density"
        }
        displayName = "Density"
        doc = """If non-zero, defines the density of the material. This can be
        used for body mass computation, see PhysicsMassAPI.
        Note that if the density is 0.0 it is ignored.
        Units: mass/distance/distance/distance"""
    )
}

class "OmniPhysicsDeformableMaterialAPI"
(
    customData = {
        string className = "DeformableMaterialAPI"
    }

    doc = """Applied to Material in addition to PhysicsMaterialAPI.
    Defines additional material properties for deformable bodies."""

    inherits = </APISchemaBase>
    prepend apiSchemas = ["OmniPhysicsBaseMaterialAPI"]
)
{

    float omniphysics:youngsModulus = 0.0 (
        customData = {
            string apiName = "youngsModulus"
        }
        displayName = "Young's Modulus"
        doc = """Young's modulus, i.e. the tensile stiffness of the material.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )

    float omniphysics:poissonsRatio = 0.25 (
        customData = {
            string apiName = "poissonsRatio"
        }

        displayName = "Poisson's Ratio"
        doc = """Poissons's ratio which defines the material's volume
        preservation under stress.
        Range: [0, 0.5]
        Units: None"""
    )
}

class "OmniPhysicsSurfaceDeformableMaterialAPI"
(
    customData = {
        string className = "SurfaceDeformableMaterialAPI"
    }

    doc = """Applied to Material in addition to PhysicsMaterialAPI and
    DeformableMaterialAPI. Defines additional material properties for
    surface deformable bodies."""

    inherits = </APISchemaBase>
    prepend apiSchemas = ["OmniPhysicsDeformableMaterialAPI"]
)
{
    float omniphysics:surfaceThickness = 0.0 (
        customData = {
            string apiName = "surfaceThickness"
        }
        displayName = "Surface Thickness"
        doc = """Surface thickness.
        Units: distance"""
    )

    float omniphysics:surfaceStretchStiffness = 0.0 (
        customData = {
            string apiName = "surfaceStretchStiffness"
        }
        displayName = "Surface Stretch Stiffness"
        doc = """Optional override for stretching stiffness; by default derived
        from youngsModulus and surfaceThickness.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )

    ### Is Newtons per degree of shear deformation the right unit description?
    float omniphysics:surfaceShearStiffness = 0.0 (
        customData = {
            string apiName = "surfaceShearStiffness"
        }
        displayName = "Surface Shear Stiffness"
        doc = """Optional override for shearing stiffness; by default derived
        from youngsModulus and surfaceThickness.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )

    float omniphysics:surfaceBendStiffness = 0.0 (
        customData = {
            string apiName = "surfaceBendStiffness"
        }
        displayName = "Surface Bend Stiffness"
        doc = """Optional override for bending stiffness; by default derived
        from youngsModulus and surfaceThickness.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )
}

class "OmniPhysicsCurvesDeformableMaterialAPI"
(
    customData = {
        string className = "CurvesDeformableMaterialAPI"
    }

    doc = """The proposed curves deformable schema is a work in progress!
    Applied to Material in addition to PhysicsMaterialAPI and
    DeformableMaterialAPI. Defines additional material properties for
    curves deformable bodies."""

    inherits = </APISchemaBase>
    prepend apiSchemas = ["OmniPhysicsDeformableMaterialAPI"]
)
{
    float omniphysics:curveThickness = 0.0 (
        customData = {
            string apiName = "curveThickness"
        }
        displayName = "Curve Thickness"
        doc = """Diameter along curve.
        Units: distance"""
    )

    float omniphysics:curveStretchStiffness = 0.0 (
        customData = {
            string apiName = "curveStretchStiffness"
        }
        displayName = "Curve Stretch Stiffness"
        doc = """Optional override for stretching stiffness; by default derived
        from youngsModulus and curveThickness.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )

    float omniphysics:curveBendStiffness = 0.0 (
        customData = {
            string apiName = "curveBendStiffness"
        }
        displayName = "Curve Bend Stiffness"
        doc = """Optional override for bending stiffness; by default derived
        from youngsModulus and curveThickness.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )

    float omniphysics:curveTwistStiffness = 0.0 (
        customData = {
            string apiName = "curveTwistStiffness"
        }
        displayName = "Curve Twist Stiffness"
        doc = """Optional override for twisting stiffness; by default derived
        from youngsModulus and curveThickness.
        Units are equivalent to Pascals or force per area.
        Range: [0, inf)
        Units: mass/(distance*seconds*seconds)"""
    )
}

class "OmniPhysicsVolumeDeformableSimAPI"
(
    customData = {
        string className = "VolumeDeformableSimAPI"
    }

    doc = """Identifies a UsdGeomTetMesh to be used as the simulation mesh for
    a volume deformable body, distinguishing it from geometries used exclusively
    for graphics or collision.
    A volume deformable body requires exactly one tetrahedral simulation mesh,
    which can either have both DeformableBodyAPI and VolumeDeformableSimAPI
    applied, or, in a hierarchical setup, be the direct child of the root with
    DeformableBodyAPI.
    The simulation API also defines attributes to describe the rest shape of the 
    volume deformable body."""

    inherits = </APISchemaBase>
)
{
    point3f[] omniphysics:restShapePoints (
        customData = {
            string apiName = "restShapePoints"
        }
        displayName = "Rest Shape Points"
        doc = """Describes the rest shape in (local) space for a deformable body
        simulation mesh."""
    )

    int4[] omniphysics:restTetVtxIndices (
        customData = {
            string apiName = "restTetVtxIndices"
        }
        displayName = "Rest Tetrahedron Vertex Indices"
        doc = """Per tetrahedral element indices into restShapePoints to describe
        the rest shape of each tetrahedron. This allows for restTetIndices to
        have length up to 4*len(restShapePoints) to allow for disjoint
        per-element rest shape description, or a more compact array when all
        tetrahedra share coincident points to describe the rest shape of the
        deformable body simulation tetmesh."""
    )
}

class "OmniPhysicsSurfaceDeformableSimAPI"
(
    customData = {
        string className = "SurfaceDeformableSimAPI"
    }

    doc = """Identifies a UsdGeomMesh to be used as the simulation mesh for
    a surface deformable body, distinguishing it from geometries used
    exclusively for graphics or collision.
    A surface deformable body requires exactly one simulation mesh, limited to
    only triangular faces. The simulation mesh can either have both
    DeformableBodyAPI and SurfaceDeformableSimAPI applied, or, in a hierarchical
    setup, be the direct child of the root with DeformableBodyAPI.
    The simulation API also defines attributes to describe the rest shape of the 
    surface deformable body."""

    inherits = </APISchemaBase>
)
{
    # Planar shape of triangles
    point3f[] omniphysics:restShapePoints (
        customData = {
            string apiName = "restShapePoints"
        }
        displayName = "Rest Shape Points"
        doc = """Describes the per triangle planar shape in (local) space for a
        surface deformable body. While panel based cloth systems may only
        require UV coordinates and not require a third component, doing so makes
        it convenient for an application to support non-planar shells with
        a rest shape described in 3D.
        One can still use this array for per-face UVs with a little wasted space."""
    )

    int3[] omniphysics:restTriVtxIndices (
        customData = {
            string apiName = "restTriVtxIndices"
        }
        displayName = "Rest Triangle Vertex Indices"
        doc = """Per triangle element indices into restShapePoints to describe
        the rest shape of each triangle face. This allows for
        restTriVtxIndices to have length up to 3*len(restShapePoints) to
        allow for a disjoint per-element rest shape description, or a
        more compact array when all triangles share conincident points
        to describe the rest shape of the surface deformable body triangle mesh."""
    )

    uniform token omniphysics:restBendAnglesDefault = "flatDefault" (
        customData = {
            string apiName = "restBendAnglesDefault"
        }
        allowedTokens = ["flatDefault", "restShapeDefault"]
        displayName = "Rest Bend Angles Default"
        doc = """Default method for defining rest dihedral angles between
        adjacent triangles, which are not explicitely specified with
        restAdjTriPairs and restBendAngles:
        "flatDefault" - Default rest dihedral bending angles are zero.
        "restShapeDefault" - Default rest dihedral bending angles are defined by
        the normals of the adjacent triangles in the configuration given by the
        restShapePoints. The adjacency is defined by the topology of the 
        simulation mesh: GeomMesh:faceVertexIndices."""
    )

    int2[] omniphysics:restAdjTriPairs (
        customData = {
            string apiName = "restAdjTriPairs"
        }
        displayName = "Adjacent Triangle Pairs"
        doc = """Array of adjacent triangle pairs to define dihedral rest bending
        angles explicitely, overriding the default rest angles. Each entry
        corresponds to an angle specified in restBendAngles."""
    )

    float[] omniphysics:restBendAngles (
        customData = {
            string apiName = "restBendAngles"
        }
        displayName = "Rest Bend Angles"
        doc = """Rest angles in degrees. Length of restBendAngles should match
        length of restAdjTriPairs. For all adjacent triangle pairs not specified
        via restAdjTriPairs and restBendAngles, the default dihedral angle given
        by restBendAnglesDefault is assumed. 
        Range: [-180.0, 180.0)
        Units: degrees"""
    )
}

class "OmniPhysicsCurvesDeformableSimAPI"
(
    customData = {
        string className = "CurvesDeformableSimAPI"
    }

    doc = """The proposed curves deformable schema is a work in progress! 
    Identifies a UsdGeomBasisCurves or UsdGeomBasisCurvesNetwork to be 
    used as the simulation geometry for a curves deformable body, distinguishing
    it from geometries used exclusively for graphics or collision.
    A curves deformable body requires exactly one simulation curves geometry,
    limited to only linear segments. The simulation geometry can either have
    both DeformableBodyAPI and CurvesDeformableSimAPI applied, or, in
    a hierarchical setup, be the direct child of the root with DeformableBodyAPI.
    The simulation API also defines attributes to describe the rest shape of the 
    curves deformable body."""

    inherits = </APISchemaBase>
)
{
    point3f[] omniphysics:restShapePoints (
        customData = {
            string apiName = "restShapePoints"
        }
        displayName = "Rest Shape Points"
        doc = """Describes the rest shape in (local) space for
        a UsdGeomBasisCurves or a UsdGeomBasisCurvesNetwork."""
    )

    int[] omniphysics:restCrvVtxIndices (
        customData = {
            string apiName = "restCrvVtxIndices"
        }
        displayName = "Rest Curve Vertex Indices"
        doc = """If the shape is a UsdGeomBasisCurvesNetwork, restCrvVtxIndices
        specifies a flat list of the index into the restShapePoints attribute of
        each vertex of each curve. This allows restCrvVtxIndices to describe
        a disjoint per-curve rest shape that differs from any coincident points
        described by curveVertexIndices. If the simulation geometry is
        a UsdGeomBasisCurves, then restCrvVtxIndices is not applicable."""
    )

    normal3f[] omniphysics:restNormals (
        customData = {
            string apiName = "restNormals"
        }
        displayName = "Rest Normals"
        doc = """Describes the orientation of the rest curves.
        Like normals, restNormals is not a generic primvar but the number of
        elements in this attribute will be determined by its 'interpolation'.
        See \\ref SetRestNormalsInterpolation(). For example, varying
        interpolation can be used to specify a normal per curve segment, as
        described by \\ref UsdGeomBasisCurves_PrimvarInterpolation."""
    )
}

class "OmniPhysicsDeformablePoseAPI"
(
    customData = {
        string className = "DeformablePoseAPI"
        token apiSchemaType = "multipleApply"
        token propertyNamespacePrefix = "deformablePose"
    }

    doc = """Defines a deformable mesh pose which can be used for one or
    multiple purposes. Multiple pose APIs can be specified for different
    purposes. The pose API instance name can be chosen arbitrarily."""

    inherits = </APISchemaBase>
)
{
    uniform token[] omniphysics:purposes(
        customData = {
            string apiName = "purposes"
        }
        displayName = "Purposes"
        doc = """The set of purposes this pose is used for.
        "bindPose" - The pose in which graphical UsdGeomPointBased and
        deformable simulation meshes are bound to each other. The bindPose
        purpose needs to be specified on the simulation mesh and all graphical
        meshes if a specific bind pose is needed. If not specified, the default
        mesh points are used for the embedding.
        "selfCollisionFilterPose" - The pose used for self collision 
        filtering. Ovelapping domains of the mesh in this pose are excluded 
        from self collision. The selfCollisionFilterPose purpose needs to be
        specified on the simulation mesh only. If not specified, the default
        mesh points are used for self collision filtering."""

        allowedTokens = ["bindPose","selfCollisionFilterPose"]
    )

    point3f[] omniphysics:points(
        customData = {
            string apiName = "points"
        }
        displayName = "Points"
        doc = """The points defining the pose of a mesh. The number of
        points needs to match the number of points in the mesh."""
    )
}

class OmniPhysicsAttachment "OmniPhysicsAttachment"
(
    customData = {
        string className = "Attachment"
    }
    doc = """Base class for attachments between two suitable deformable body
    simulation meshes, or between a deformable body simulation mesh and 
    a UsdGeomXformable's coordinate frame.
    """

    inherits = </Imageable>
)
{
    bool omniphysics:attachmentEnabled = true (
        customData = {
            string apiName = "attachmentEnabled"
        }
        displayName = "Attachment Enabled"
        doc = """Determines if this PhysicsAttachment is enabled."""
    )

    rel omniphysics:src0 (
        customData = {
            string apiName = "src0"
        }
        displayName = "Source 0"
        doc = """Relationship to a single deformable body's simulation mesh.
        The attachment locations are specified in the derived attachment
        class."""
    )

    rel omniphysics:src1 (
        customData = {
            string apiName = "src1"
        }
        displayName = "Source 1"
        doc = """Relationship to a single deformable body's simulation mesh or
        a single UsdGeomXformable. The attachment locations are specified in the
        derived attachment class."""
    )

    float omniphysics:stiffness = inf (
        customData = {
            string apiName = "stiffness"
        }
        displayName = "Stiffness"
        doc = """Distance proportional factor for the attachment.
        "inf" implies a hard constraint if the simulator can support it.
        Range: [0, inf)
        Units: mass/second/second"""
    )

    float omniphysics:damping = 0.0 (
        customData = {
            string apiName = "damping"
        }
        displayName = "Damping"
        doc = """Proportional factor of the force acting against the direction
        of relative motion.
        Range: [0, inf)
        Units: mass/second"""
    )
}

class OmniPhysicsVtxVtxAttachment "OmniPhysicsVtxVtxAttachment"
(
    customData = {
        string className = "VtxVtxAttachment"
    }
    doc = """Describes a fixed binding attachment between vertices of two
    UsdGeomPointBased deformable body simulation meshes."""

    inherits = </OmniPhysicsAttachment>
)
{
    int[] omniphysics:vtxIndicesSrc0(
        customData = {
            string apiName = "vtxIndicesSrc0"
        }
        displayName = "Vertex Indices Source 0"
        doc = """Array of vertex indices from UsdGeomPointBased src0."""
    )

    int[] omniphysics:vtxIndicesSrc1(
        customData = {
            string apiName = "vtxIndicesSrc1"
        }
        displayName = "Vertex Indices Source 1"
        doc = """Array of vertex indices from UsdGeomPointBased src1.
        There should be exactly one vertex index for each vertex index
        in vtxIndicesSrc0."""
    )
}

class OmniPhysicsVtxTriAttachment "OmniPhysicsVtxTriAttachment"
(
    customData = {
        string className = "VtxTriAttachment"
    }
    doc = """Describes a fixed binding attachment between vertices and triangle
    faces of two suitable deformable body simulation meshes. The src1 relationship
    should point to either a UsdGeomMesh or a UsdGeomTetMesh (in which case surface 
    triangles are referenced)."""

    inherits = </OmniPhysicsAttachment>
)
{
    int[] omniphysics:vtxIndicesSrc0(
        customData = {
            string apiName = "vtxIndicesSrc0"
        }
        displayName = "Vertex Indices Source 0"
        doc = """Array of vertex indices from UsdGeomPointBased src0"""
    )

    int[] omniphysics:triIndicesSrc1(
        customData = {
            string apiName = "triIndicesSrc1"
        }
        displayName = "Triangle Indices Source 1"
        doc = """Array of triangle indices from UsdGeomMesh/UsdGeomTetMesh src1.
        There should be exactly one triangle index for each vertex index in
        vtxIndicesSrc0."""
    )

    vector3f[] omniphysics:triCoordsSrc1(
        customData = {
            string apiName = "triCoordsSrc1"
        }
        displayName = "Triangle Coordinates Source 1"
        doc = """Triangle relative coordinates of the form U,V portion of
        barycentric UVW coordinates and a normal offset from the
        triangle. There should be exactly one set of triangle coordinates
        corresponding to each vertex index and triangle index."""
    )
}

class OmniPhysicsVtxTetAttachment "OmniPhysicsVtxTetAttachment"
(
    customData = {
        string className = "VtxTetAttachment"
    }
    doc = """Describes a fixed binding attachment between vertices and
    tetrahedra of two suitable deformable body simulation meshes.
    The src1 relationship should point to a UsdGeomTetMesh."""

    inherits = </OmniPhysicsAttachment>
)
{
    int[] omniphysics:vtxIndicesSrc0(
        customData = {
            string apiName = "vtxIndicesSrc0"
        }
        displayName = "Vertex Indices Source 0"
        doc = """Array of vertex indices from UsdGeomPointBased src0"""
    )

    int[] omniphysics:tetIndicesSrc1(
        customData = {
            string apiName = "tetIndicesSrc1"
        }
        displayName = "Tetrahedron Indices Source 1"
        doc = """Array of tetrahedron indices from UsdGeomTetMesh src1.
        There should be exactly one tet index for each vertex index in
        vtxIndicesSrc0."""
    )

    vector3f[] omniphysics:tetCoordsSrc1(
        customData = {
            string apiName = "tetCoordsSrc1"
        }
        displayName = "Tetrahedra Coordinates Source 1"
        doc = """Barycentric coordinates of the form U,V,W of the point wrt.
        the points of the tetrahedra. There should be exactly one
        set of tetrahedra coordinates corresponding to each vertex index and
        tet index."""
    )
}

class OmniPhysicsVtxCrvAttachment "OmniPhysicsVtxCrvAttachment"
(
    customData = {
        string className = "VtxCrvAttachment"
    }
    doc = """The proposed curves deformable schema is a work in progress!
    Describes a fixed binding attachment between vertices and curves
    of two suitable deformable body simulation meshes. The src1 relationship
    should point to a UsdGeomBasisCurves or UsdGeomBasisCurvesNetwork."""

    inherits = </OmniPhysicsAttachment>
)
{
    int[] omniphysics:vtxIndicesSrc0(
        customData = {
            string apiName = "vtxIndicesSrc0"
        }
        displayName = "Vertex Indices"
        doc = """Array of vertex indices from UsdGeomPointBased src0."""
    )

    int2[] omniphysics:crvSegIndicesSrc1(
        customData = {
            string apiName = "crvSegIndicesSrc1"
        }
        displayName = "Curve Segment Indices Source 1"
        doc = """Array of (curve index, segment index) pairs from src0.
        There should be exactly one pair for each vertex index in vtxIndicesSrc0.
        The curve index specifies the index of the curve from
        UsdGeomBasisCurves/UsdGeomBasisCurvesNetwork src1, and the
        segment index identifies the segment within the curve."""
    )

    vector3f[] omniphysics:crvSegCoordsSrc1(
        customData = {
            string apiName = "crvSegCoordsSrc1"
        }
        displayName = "Curve Segment Coordinates Source 1"
        doc = """Segment relative coordinates of the form U (parametric
        coordinate along the segment), VW (offset vector defined in the
        coordinate frame spanned by {N, NxT}, where N is the interpolated unit
        curve normal and T is the unit vector tangential to the segment). 
        There should be exactly one coordinate set for each curve segment in
        crvSegIndicesSrc1."""
    )
}

class OmniPhysicsVtxXformAttachment "OmniPhysicsVtxXformAttachment"
(
    customData = {
        string className = "VtxXformAttachment"
    }
    doc = """Describes a fixed binding attachment between vertices and a
    UsdGeomXformable's coordinate frame. The vertices must always be from a
    deformable body's simulation mesh. If the xformable is a rigid body or
    a prim of the subtree of a rigid body, then the attachment is treated by
    the solver as a two way constraint."""

    inherits = </OmniPhysicsAttachment>
)
{
    int[] omniphysics:vtxIndicesSrc0(
        customData = {
            string apiName = "vtxIndicesSrc0"
        }
        displayName = "Vertex Indices Source 0"
        doc = """Array of vertex indices from UsdGeomPointBased src0."""
    )

    point3f[] omniphysics:localPositionsSrc1(
        customData = {
            string apiName = "localPositionsSrc1"
        }
        displayName = "Local Positions Source 1"
        doc = """Spatial offsets of the attachment locations in the coordinate
        frame described by UsdGeomXformable src1."""
    )
}

class OmniPhysicsTetXformAttachment "OmniPhysicsTetXformAttachment"
(
    customData = {
        string className = "TetXformAttachment"
    }
    doc = """Describes a fixed binding attachment between tetrahedra and a
    UsdGeomXformable's coordinate frame. The tetrahedra must always be from a
    deformable body's simulation mesh. If the xformable is a rigid body or
    a prim of the subtree of a rigid body, then the attachment is treated by
    the solver as a two way constraint."""

    inherits = </OmniPhysicsAttachment>
)
{
    int[] omniphysics:tetIndicesSrc0(
        customData = {
            string apiName = "tetIndicesSrc0"
        }
        displayName = "Tetrahedron Indices Source 0"
        doc = """Array of tetrahedron indices from UsdGeomTetMesh src0."""
    )

    vector3f[] omniphysics:tetCoordsSrc0(
        customData = {
            string apiName = "tetCoordsSrc0"
        }
        displayName = "Tetrahedra Coordinates Source 0"
        doc = """Barycentric coordinates of the form U,V,W of the point wrt.
        the points of the tetrahedra. There should be exactly one
        set of tetrahedra coordinates corresponding to each tet index."""
    )

    point3f[] omniphysics:localPositionsSrc1(
        customData = {
            string apiName = "localPositionsSrc1"
        }
        displayName = "Local Positions Source 1"
        doc = """Spatial offsets of the attachment locations in the coordinate
        frame described by UsdGeomXformable src1."""
    )
}

class OmniPhysicsTriTriAttachment "OmniPhysicsTriTriAttachment"
(
    customData = {
        string className = "TriTriAttachment"
    }
    doc = """Describes a fixed binding attachment between a point on a triangle
    face and a point on another triangle face of two suitable deformable body
    simulation meshes. Both src0 and src1 relationship should each point to
    either a UsdGeomMesh or a UsdGeomTetMesh (in which case surface 
    triangles are referenced)."""

    inherits = </OmniPhysicsAttachment>
)
{
    int[] omniphysics:triIndicesSrc0(
        customData = {
            string apiName = "triIndicesSrc0"
        }
        displayName = "Triangle Indices Source 0"
        doc = """Array of triangle indices from UsdGeomMesh/UsdGeomTetMesh src0."""
    )

    vector3f[] omniphysics:triCoordsSrc0(
        customData = {
            string apiName = "triCoordsSrc0"
        }
        displayName = "Triangle Coordinates Source 0"
        doc = """Triangle relative coordinates of the form U,V portion of
        barycentric UVW coordinates and a normal offset from the triangle.
        There should be exactly one set of triangle coordinates
        corresponding to each entry in triIndicesSrc0."""
    )

    int[] omniphysics:triIndicesSrc1(
        customData = {
            string apiName = "triIndicesSrc1"
        }
        displayName = "Triangle Indices Source 1"
        doc = """Array of triangle indices from UsdGeomMesh/UsdGeomTetMesh src1.
        There should be exactly one triangle index for each triangle index in
        triIndicesSrc0."""
    )

    vector3f[] omniphysics:triCoordsSrc1(
        customData = {
            string apiName = "triCoordsSrc1"
        }
        displayName = "Triangle Coordinates Source 1"
        doc = """Triangle relative coordinates of the form U,V portion of
        barycentric UVW coordinates and a normal offset from the triangle. 
        There should be exactly one set of triangle coordinates
        corresponding to each entry in triIndicesSrc1."""
    )
}


class OmniPhysicsElementCollisionFilter "OmniPhysicsElementCollisionFilter"
(
    customData = {
        string className = "ElementCollisionFilter"
    }
    doc = """Describes an element wise collision filter for deformable body
    collision prims with PhysicsCollisionAPI. The filter specifies two suitable
    collision GPrims which are the source of the elements. The sources may be
    indentical to control self collision filtering. At least one source prim
    needs to represent a deformable body collider, and up to one can either
    be a rigid body or static collider.
    The filtering for deformable sources is based on element indices representing
    - triangles for UsdGeomMesh
    - surface triangles for UsdGeomTetMesh
    - segments for UsdGeomBasisCurves/UsdGeomBasisCurvesNetwork
    - points for UsdGeomPoints
    Filtering a specific triangle of a mesh means omitting collision tests
    against its face, vertex, and edge features. However, vertices and edges
    shared with adjacent unfiltered triangles are not filtered. Similarly,
    vertices of filtered curve segments are not filtered if they are shared with
    adjacent unfiltered segments.
    If the source is either a static or rigid collider, the whole geometry is
    filtered and no elements need to be specified. Which elements are filtered
    against which, is specified using pairs of element groups. Each pair of
    groups defines the elements of both sources that should not collide with
    each other.
    E.g.: triangles [4, 5, 6] of one collider mesh are each not colliding
    against any triangles [12, 13] of the other collider mesh.
    The group sizes are specified with groupElemCounts0 and groupElemCounts1,
    two arrays of matching size. The element indices of each group are
    consecutively stored for all groups in groupElemIndices0 and
    groupElemIndices1, similarly to how faceVertexCounts specifies the number of
    vertices per face and faceVertexIndices specifies the vertex indices per
    face in order.
    Two special cases: 
    - An empty groupElemCounts array indicates that the
    corresponding source is filtered as a whole, for example for rigid or static
    colliders.
    - A group element count of zero indicates that the corresponding source is
    filtered as a whole with respect to the paired up group of the other source."""

    inherits = </Imageable>
)
{
    bool omniphysics:filterEnabled = true (
        customData = {
            string apiName = "filterEnabled"
        }
        displayName = "Filter Enabled"
        doc = """Determines if this PhysicsElementCollisionFilter is enabled."""
    )

    rel omniphysics:src0 (
        customData = {
            string apiName = "src0"
        }
        displayName = "Source 0"
        doc = """Relationship to a single deformable body's collider which is
        the source of elements referenced by groupElemIndices0 or
        a rigid body/static collider."""
    )

    rel omniphysics:src1 (
        customData = {
            string apiName = "src1"
        }
        displayName = "Source 1"
        doc = """Relationship to a single deformable body's collider which is
        the source of elements referenced by groupElemIndices1 
        or a rigid body/static collider."""
    )

    uint[] omniphysics:groupElemCounts0(
        customData = {
            string apiName = "groupElemCounts0"
        }
        displayName = "Group Element Counts 0"
        doc = """Array of element counts per filter group for src0. Same size as 
        groupElemCounts1 or empty."""
    )

    uint[] omniphysics:groupElemCounts1(
        customData = {
            string apiName = "groupElemCounts1"
        }
        displayName = "Group Element Counts 1"
        doc = """Array of element counts per filter group for src1. Same size as 
        groupElemCounts0 or empty."""
    )

    uint[] omniphysics:groupElemIndices0(
        customData = {
            string apiName = "groupElemIndices0"
        }
        displayName = "Group Element Indices 0"
        doc = """Array of element indices ordered according to groupElemCounts0,
        referencing elements of src0. If the src is a curves prim,
        then each entry consists of two indices: (curve index, segment index)."""
    )

    uint[] omniphysics:groupElemIndices1(
        customData = {
            string apiName = "groupElemIndices1"
        }
        displayName = "Group Element Indices 1"
        doc = """Array of element indices ordered according to groupElemCounts1,
        referencing elements of src1. If the src is a curves prim, 
        then each entry consists of two indices: (curve index, segment index)."""
    )
}


